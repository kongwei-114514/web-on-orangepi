<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Live2D çº¢è‰æ – - å¢å¼ºç‰ˆ</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    #canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 15px;
      border-radius: 10px;
      font-family: Arial, sans-serif;
      font-size: 20px;
      max-width: 300px;
      transition: opacity 0.3s;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 10px;
      font-family: Arial, sans-serif;
    }
    button {
      background: #4CAF50;
      border: none;
      color: white;
      padding: 8px 15px;
      margin: 0 5px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 20px;
    }
    button:hover {
      background: #45a049;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="status">åŠ è½½ä¸­...</div>
  <div id="controls" style="display:none;">
    <button id="playMotion">æ’­æ”¾åŠ¨ä½œ</button>
    <button id="changeExpression">åˆ‡æ¢è¡¨æƒ…</button>
  </div>
  
  <script src="/cdn/live2d.js"></script>
  <script src="/cdn/pixi.min.js"></script>
  <script src="/cdn/cubism4.js"></script>
  
  <script>
    (async () => {
      const app = new PIXI.Application({ 
        view: document.getElementById('canvas'), 
        transparent: true,
        resizeTo: window,
        autoDensity: true
      });
      
      const statusElement = document.getElementById('status');
      const controlsElement = document.getElementById('controls');
      
      // å£°æ˜å˜é‡ï¼Œå°†åœ¨æ¨¡å‹åŠ è½½åèµ‹å€¼
      let model;
      
      // å®šä¹‰ resizeModel å‡½æ•°
      function resizeModel() {
        if (!model || !model.originalWidth) {
          console.warn('æ¨¡å‹æœªå°±ç»ªï¼Œè·³è¿‡è°ƒæ•´');
          return;
        }
        
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        console.log(`ğŸ–¥ï¸ å±å¹•: ${screenWidth}x${screenHeight}, æ¨¡å‹åŸå§‹: ${model.originalWidth}x${model.originalHeight}`);
        
        // ä½¿ç”¨åŸå§‹å°ºå¯¸è®¡ç®—
        const maxWidth = screenWidth * 0.6;
        const maxHeight = screenHeight * 0.7;
        
        const scaleX = maxWidth / model.originalWidth;
        const scaleY = maxHeight / model.originalHeight;
        let scale = scaleY*1.2;
        
        // é™åˆ¶ç¼©æ”¾èŒƒå›´
        scale = Math.max(0.15, Math.min(0.4, scale));
        
        console.log(`ğŸ“Š ç¼©æ”¾è®¡ç®—: å®½${scaleX.toFixed(3)} é«˜${scaleY.toFixed(3)} æœ€ç»ˆ${scale.toFixed(3)}`);
        
        model.scale.set(scale);
        model.x = screenWidth / 2;
        model.y = screenHeight / 2;
        
        if (model.anchor) model.anchor.set(0.5, 0.5);
        
        console.log(`âœ… è°ƒæ•´å®Œæˆ: ä½ç½®(${Math.round(model.x)}, ${Math.round(model.y)}), ç¼©æ”¾${scale.toFixed(3)}`);
      }
      
      // ä¼˜åŒ–çš„å°ºå¯¸ç›‘å¬å‡½æ•°
      function setupOptimizedResizeHandler() {
        let lastWidth = window.innerWidth;
        let lastHeight = window.innerHeight;
        let resizeTimeout;
        
        const checkResize = () => {
          const currentWidth = window.innerWidth;
          const currentHeight = window.innerHeight;
          
          if (Math.abs(currentWidth - lastWidth) > 5 || Math.abs(currentHeight - lastHeight) > 5) {
            console.log(`ğŸ“¦ å®¹å™¨å˜åŒ–: ${lastWidth}x${lastHeight} â†’ ${currentWidth}x${currentHeight}`);
            lastWidth = currentWidth;
            lastHeight = currentHeight;
            
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeModel, 150);
          }
        };
        
        setInterval(checkResize, 250);
      }
      
      // æ·»åŠ  iframe å®¹å™¨å°ºå¯¸ç›‘å¬
      function setupContainerResizeListener() {
        // ç›‘å¬çˆ¶é¡µé¢æ¶ˆæ¯ï¼ˆå¦‚æœæ˜¯ä»çˆ¶é¡µé¢å‘é€çš„ï¼‰
        window.addEventListener('message', function(event) {
          if (event.data && event.data.type === 'resize') {
            console.log('ğŸ“¨ æ”¶åˆ°çˆ¶é¡µé¢è°ƒæ•´æ¶ˆæ¯');
            setTimeout(resizeModel, 100);
          }
        });
        
        // ä½¿ç”¨ ResizeObserver ç›‘å¬ body å°ºå¯¸å˜åŒ–
        if (window.ResizeObserver) {
          const observer = new ResizeObserver(entries => {
            for (let entry of entries) {
              console.log('ğŸ” ResizeObserver æ£€æµ‹åˆ°å®¹å™¨å°ºå¯¸å˜åŒ–');
              setTimeout(resizeModel, 100);
            }
          });
          
          observer.observe(document.body);
          console.log('âœ… ResizeObserver ç›‘å¬å·²å¯åŠ¨');
        }
      }
      
      try {
        // åŠ è½½æ¨¡å‹
        model = await PIXI.live2d.Live2DModel.from('https://static.amadeus-web.top/live2dmodels/steinsGateKurisuNew/çº¢è‰æ –.model3.json');
        model.physics = true;
        
        // ä¿å­˜åŸå§‹å°ºå¯¸ - å…³é”®ä¿®å¤ï¼
        model.originalWidth = model.width;
        model.originalHeight = model.height;
        console.log(`ğŸ“ æ¨¡å‹åŸå§‹å°ºå¯¸: ${model.originalWidth}x${model.originalHeight}`);
        
        app.stage.addChild(model);

        // ç«‹å³æ‰§è¡Œåˆå§‹å¸ƒå±€
        setTimeout(() => {
          resizeModel();
        }, 100); // ç¨å¾®å»¶è¿Ÿç¡®ä¿æ¨¡å‹å®Œå…¨åˆå§‹åŒ–

        // å¯åŠ¨å°ºå¯¸ç›‘å¬
        setupOptimizedResizeHandler();
        setupContainerResizeListener();
        
        // åŠ¨ä½œå’Œè¡¨æƒ…å®šä¹‰
        const randomMotions = ['neutral','anger','joy','sadness','shy','shy2','smile1','smile2','surprise','unhappy','random1', 'random3', 'random4', 'random5'];
        const expressions = ['neutral', 'anger', 'joy', 'sadness', 'shy', 'shy2', 'smile1', 'smile2', 'surprise', 'unhappy'];
        let currentExpressionIndex = 0;
        let currentMotionIndex = 0;
        
        function setupAutoBlink() {
          const eyeLOpen = "ParamEyeLOpen";
          const eyeROpen = "ParamEyeROpen";
          
          if (model.internalModel && model.internalModel.coreModel) {
            const coreModel = model.internalModel.coreModel;
            const eyeLOpenIndex = coreModel.getParameterIndex(eyeLOpen);
            const eyeROpenIndex = coreModel.getParameterIndex(eyeROpen);
            
            if (eyeLOpenIndex !== -1 && eyeROpenIndex !== -1) {
              
              function blink() {
                let step = 0;
                const steps = 10;
                const duration = 300; // çœ¨çœ¼æŒç»­æ—¶é—´(æ¯«ç§’)
                
                const blinkTimer = setInterval(() => {
                  let value;
                  if (step < steps / 2) {
                    value = 1 - (step / (steps / 2)); // é—­çœ¼
                  } else {
                    value = (step - steps / 2) / (steps / 2); // ççœ¼
                  }
                  
                  coreModel.setParameterValueByIndex(eyeLOpenIndex, value);
                  coreModel.setParameterValueByIndex(eyeROpenIndex, value);
                  
                  step++;
                  if (step >= steps) {
                    clearInterval(blinkTimer);
                    coreModel.setParameterValueByIndex(eyeLOpenIndex, 1);
                    coreModel.setParameterValueByIndex(eyeROpenIndex, 1);
                    
                    // âœ… çœ¨å®Œä¸€æ¬¡åï¼Œå®‰æ’ä¸‹ä¸€æ¬¡çœ¨çœ¼ï¼ˆæ–°éšæœºé—´éš”ï¼‰
                    const nextBlinkInterval = 2000 + Math.random() * 6000; // 2~8 ç§’
                    setTimeout(blink, nextBlinkInterval);
                  }
                }, duration / steps);
              }
              
              // é¦–æ¬¡çœ¨çœ¼å»¶è¿Ÿï¼ˆä¹Ÿéšæœºï¼‰
              const firstBlink = 2000 + Math.random() * 6000;
              setTimeout(blink, firstBlink);
              
              console.log("âœ… è‡ªåŠ¨çœ¨çœ¼å·²å¯ç”¨ï¼ˆåŠ¨æ€é—´éš”ï¼‰");
            } else {
              console.warn("âš ï¸ æ¨¡å‹ä¸æ”¯æŒè‡ªåŠ¨çœ¨çœ¼å‚æ•°");
            }
          }
        }
        
        // å¤´éƒ¨å’Œçœ¼çƒè·Ÿéšé¼ æ ‡ç‚¹å‡»ï¼ˆå¸¦å»¶æ—¶å¹³æ»‘ç§»åŠ¨ï¼‰
        function lookAtMousePosition(event) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = event.clientX - rect.left;
          const mouseY = event.clientY - rect.top;
          
          const modelX = model.x;
          const modelY = model.y;
          const modelWidth = model.width * model.scale.x;
          const modelHeight = model.height * model.scale.y;
          
          // è®¡ç®—ç‚¹å‡»ç‚¹ç›¸å¯¹äºæ¨¡å‹ä¸­å¿ƒçš„åç§»ï¼ˆ-1 åˆ° 1ï¼‰
          // ä¿®å¤ï¼šä¸Šä¸‹åè½¬
          const offsetX = (mouseX - modelX) / (modelWidth / 2); // -1 (å·¦) åˆ° 1 (å³)
          const offsetY = -((mouseY - modelY) / (modelHeight / 2)); // -1 (ä¸‹) åˆ° 1 (ä¸Š) - æ³¨æ„è´Ÿå·
          
          // é™åˆ¶åç§»èŒƒå›´
          const clampedOffsetX = Math.max(-1, Math.min(1, offsetX));
          const clampedOffsetY = Math.max(-1, Math.min(1, offsetY));
          
          // è®¡ç®—ç›®æ ‡å‚æ•°å€¼
          const targetHeadX = clampedOffsetX * 30;  // å¤´éƒ¨XèŒƒå›´ Â±30
          const targetHeadY = clampedOffsetY * 30;  // å¤´éƒ¨YèŒƒå›´ Â±30
          const targetEyeX = clampedOffsetX * 1;    // çœ¼çƒXèŒƒå›´ Â±1
          const targetEyeY = clampedOffsetY * 1;    // çœ¼çƒYèŒƒå›´ Â±1
          
          // å®šä¹‰å‚æ•°å
          const headXParam = "ParamAngleX";
          const headYParam = "ParamAngleY";
          const eyeXParam = "ParamEyeBallX";
          const eyeYParam = "ParamEyeBallY";
          
          // å°è¯•ä½¿ç”¨å†…éƒ¨æ¨¡å‹è®¿é—®å‚æ•°
          if (model.internalModel && model.internalModel.coreModel) {
            const coreModel = model.internalModel.coreModel;
            
            const headXIndex = coreModel.getParameterIndex(headXParam);
            const headYIndex = coreModel.getParameterIndex(headYParam);
            const eyeXIndex = coreModel.getParameterIndex(eyeXParam);
            const eyeYIndex = coreModel.getParameterIndex(eyeYParam);
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ä»»æ„å‚æ•°å­˜åœ¨
            const paramsToSet = [
              { index: headXIndex, target: targetHeadX, name: headXParam },
              { index: headYIndex, target: targetHeadY, name: headYParam },
              { index: eyeXIndex, target: targetEyeX, name: eyeXParam },
              { index: eyeYIndex, target: targetEyeY, name: eyeYParam }
            ];
            
            if (paramsToSet.some(p => p.index !== -1)) {
              // è·å–å½“å‰å‚æ•°å€¼ä½œä¸ºèµ·å§‹ç‚¹
              const startValues = paramsToSet.map(p => 
                p.index !== -1 ? coreModel.getParameterValueByIndex(p.index) : 0
              );
              
              // åŠ¨ç”»å‚æ•°
              const duration = 500; // åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
              const steps = 30;     // åŠ¨ç”»æ­¥æ•°
              let step = 0;
              
              const moveInterval = setInterval(() => {
                step++;
                const progress = step / steps; // 0 åˆ° 1
                
                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°ï¼ˆease-outï¼‰è®©ç§»åŠ¨æ›´è‡ªç„¶
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                paramsToSet.forEach((p, i) => {
                  if (p.index !== -1) {
                    const startVal = startValues[i];
                    const currentVal = startVal + (p.target - startVal) * easeProgress;
                    coreModel.setParameterValueByIndex(p.index, currentVal);
                  }
                });
                
                if (step >= steps) {
                  clearInterval(moveInterval);
                  // ç¡®ä¿æœ€ç»ˆå€¼å‡†ç¡®
                  paramsToSet.forEach(p => {
                    if (p.index !== -1) {
                      coreModel.setParameterValueByIndex(p.index, p.target);
                    }
                  });
                  
                  statusElement.textContent = `çœ‹å‘: (${mouseX}, ${mouseY})`;
                  statusElement.style.opacity = '1';
                  setTimeout(() => statusElement.style.opacity = '0.7', 1000);
                }
              }, duration / steps);
              
            } else {
              console.warn("æœªæ‰¾åˆ°å¤´éƒ¨æˆ–çœ¼çƒå‚æ•°");
              statusElement.textContent = "æ— æ³•çœ‹å‘è¯¥ä½ç½®";
              statusElement.style.opacity = '1';
              setTimeout(() => statusElement.style.opacity = '0.7', 2000);
            }
          }
        }
        
        // åˆ‡æ¢è¡¨æƒ…
        function changeExpression() {
          const expression = expressions[currentExpressionIndex];
          currentExpressionIndex = (currentExpressionIndex + 1) % expressions.length;
          if (model.expression(expression)) {
            statusElement.textContent = `è¡¨æƒ…: ${expression}`;
            statusElement.style.opacity = '1';
            setTimeout(() => statusElement.style.opacity = '0.7', 1500);
          }
        }

        function changeMotion() {
          const motion = randomMotions[currentMotionIndex];
          currentMotionIndex = (currentMotionIndex + 1) % randomMotions.length;
          if (model.motion(motion)) {
            statusElement.textContent = `åŠ¨ä½œ: ${motion}`;
            statusElement.style.opacity = '1';
            setTimeout(() => statusElement.style.opacity = '0.7', 500);
          }
        }
        
        // å¯åŠ¨è‡ªåŠ¨çœ¨çœ¼
        setupAutoBlink();
        
        // ç»‘å®šé¼ æ ‡ç‚¹å‡»äº‹ä»¶åˆ° canvas
        document.getElementById('canvas').addEventListener('click', lookAtMousePosition);
        
        // æ§åˆ¶æŒ‰é’®äº‹ä»¶
        document.getElementById('playMotion').addEventListener('click', changeMotion);
        document.getElementById('changeExpression').addEventListener('click', changeExpression);

        statusElement.textContent = 'åŠ è½½å®Œæˆï¼ç‚¹å‡»æ¨¡å‹æˆ–ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®';
        controlsElement.style.display = 'block';
        console.log('âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼');
        console.log('æ¨¡å‹å†…éƒ¨ç»“æ„:', model.internalModel);
        if (model.internalModel && model.internalModel.coreModel) {
          console.log('æ ¸å¿ƒæ¨¡å‹å‚æ•°æ•°é‡:', model.internalModel.coreModel.getParameterCount());
        }
        
      } catch (e) {
        console.error('âŒ æ¨¡å‹åŠ è½½å¤±è´¥:', e);
        statusElement.textContent = 'åŠ è½½å¤±è´¥: ' + e.message;
      }
    })();
  </script>
</body>
</html>